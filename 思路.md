## 1.导入openzeppelin包

分为两个部分

### 1. 引入OpenZeppelin的ERC20接口和安全库

```solidity
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/utils/Address.sol";
import "@openzeppelin/contracts/utils/math/Math.sol";
```



### 2.引入OpenZeppelin的可升级合约相关库

```solidity
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol";
```

其中的AccessControlUpgradeable.sol是用来做权限认证用的，比如onlyRole(ADMIN_ROLE)

这个onlyRole修饰符 就是只有ADMIN_ROLE这个变量的用户才能调用该函数

## 2.合约继承升级库

```solidity
contract RCCStake is
    Initializable,
    UUPSUpgradeable,
    AccessControlUpgradeable,
    PausableUpgradeable
{
    using SafeERC20 for IERC20;
    using Address for address;
    using SafeMath for uint256;
    ......
    }
```

## 3.设置管理员和合约升级员角色，再定义原生币池

```solidity
// 定义合约管理员角色
bytes32 public constant ADMIN_ROLE = keccak256("ADMIN_ROLE");
// 定义合约升级员角色
bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER_ROLE");
// 原生币池的池ID（第一个池）
uint256 public constant nativeCurrency_PID = 0;
```

## 4.设置质押池，解质押请求，用户登数据结构

```solidity
// ************************************** 数据结构 **************************************

/*
任何时刻，用户应得但尚未分发的RCC数量为：
pending RCC = (user.stAmount * pool.accRCCPerST) - user.finishedRCC

用户每次存入或取出质押时，流程如下：
1. 更新池子的accRCCPerST和lastRewardBlock
2. 发放用户待领取的RCC
3. 更新用户的stAmount
4. 更新用户的finishedRCC
*/

/**
 * @dev 质押池结构体
 */
struct Pool {
    address stTokenAddress;      // 质押代币地址（原生币为0x0）
    uint256 poolWeight;          // 池子权重（决定奖励分配比例）
    uint256 lastRewardBlock;     // 上次分配奖励的区块号
    uint256 accRCCPerST;         // 累计每个质押代币分到的RCC（扩大1e18精度）
    uint256 stTokenAmount;       // 当前池子总质押量
    uint256 minDepositAmount;    // 最小质押数量
    uint256 unstakeLockedBlocks; // 解押后需要等待的区块数
}

/**
 * @dev 解押请求结构体
 */
struct UnstakeRequest {
    // 质押数量
    uint256 amount;
    // 可提现的区块号
    uint256 unlockBlocks;
}

/**
 * @dev 用户结构体
 */

struct User {
    // 用户质押的代币数量
    uint256 stamount;
    // 用户已领取的RCC数量
    uint256 finshedRCC;
    // 用户未领取的RCC数量
    uint256 pendingRCC;
    // 用户的解押请求队列
    UnstakeRequest[] requests;


}
// 挖矿开始的区块号
uint256 public startBlock;
// 挖矿结束的区块号
uint256 public endBlock;
// 每个区块的RCC奖励数量
uint256 public RCCPerBlock;

// 是否暂停体现
bool public withdrawPaused;
// 是否暂停领取奖励
bool public claimPaused;

// RCC代币合约地址
IERC20 public RCC;

// 质押池列表
Pool[] public pool;

// 用户信息映射：池ID => 用户地址 => 用户信息
mapping(uint256 => mapping(address => User)) public user;
```

## 5.设置事件

事件需要写函数的时候再写，第一时间留出空间即可